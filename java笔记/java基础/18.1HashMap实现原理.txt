
jdk 1.7 
  基于数组和链表实现的
	---[0]-----[1]----[2]---[3]---[4]----[5]----
	    |       |
	  [next]  [next]
	    |       |
	  [next2] [next2]
	  
	如上图所示，hashMap基于数组+链表方式实现
  其中有两个重要参数:  当hashMap的size>16*0.75时,数组就会发生扩容
	* 容量: 默认16
    * 负载因子: 默认0.75	

  put方法：
	* 首先会对传入的Key做一次hash运算，然后根据数组的长度取模计算在数组中的下标
	* 在计算过程中位运算比取模效率高，所有规定数组的长度为2^n,这样可以用2^n-1做位运算和取模效果一致
	* 由于数组长度有限，运算可以获得的index相同，这时候采用链表解决，HashMap 会在 table[index]处形成链表，采用头插法将数据插入到链表中


hashMap并发下出现环形链表死循环问题:
	* hashMap内部通过一个Entry<K,V>[] table 来存储数据，当调用put方法时，根据key的hashcode进行Hash计算，得出一个数组下标
	* 然后将Entry对象放进相应位置。这种情况下，可能出现不同hashcode 的下标相同，这时会将Entry进行链式存储
	* 当table的使用率超过16*0.75时，需要对数组进行扩容，扩容时定义一个新数组，并把旧数组中的entry分配到新数组中
	* ？？？？
	

	
jdk1.8中对hashMap进行了优化：
	当hash碰撞之后写入链表的长度超过了阈值(默认为8),链表将转换为 "红黑树"
	
	