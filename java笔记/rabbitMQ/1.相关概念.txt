1. 生产者和消费者：
	producer：生产者，投递消息的一方。生产者把消息交由RabbitMQ，rabbitmq之后根据标签把消息发送给感兴趣的消费者(Consumer)
		消息一般包含两个部分:
			消息体(payload):带有业务逻辑结构的数据，例如json字符串
			标签(Label):用来表述这条消息，比如一个交换器和一个路由键。
	Consumer:消费者，接收消息的一方
		* 消费者连接到MQ服务器，并订阅到队列上。当消费者消费一条数据时，只是消费消息的消息体
		* 在消息路由过程中，消息的标签会被丢弃，存入队列中的消息只有消息体，消费者也不知道消息的生产者是谁。
	Broker: 消息中间件的服务节点： 可以看做是是RabbitMQ的服务端
		
			
	Queue:队列。
		* rabbitmq消息都只能存储在队列中。生产者生成消息并最终投递到队列中，消费者从队列中获取消息并消费
		* 多个消费者可以订阅同一个队列，这时队列中的消息会被平均分摊(轮询)给多个消费者处理，而不是每个消费者都会收到所有消息
		* rabbitmq不支持队列层面的广播消费.
	
	Exchange:交换器
		* 生产者将消息发送到Exchage(交换器),由交换器将消息路由到 一个或者多个队列中。如果路由不到，或许会返回给生产者，或许直接丢弃
	
	RoutingKey：路由键
		* 生产者将消息发送给交换器的时候，一般会指定一个RoutingKey，用来指定这个消息的路由规则
		* 这个RoutingKey需要和交换器类型和绑定键(BindingKey)联合使用使用才能最终生效
		* 在交换器类型和绑定键固定的情况下，生产者可以在发送消息给交换器时，通过指定RoutingKey来决定消息流向哪里
		
	Binding:绑定 
		* 通过绑定将交换器和队列关联起来。在绑定时一般会指定一个绑定键，
		
	交换器类型：fanout、direct、topic、headers
		fanout:把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中
		direct:把消息路由到那些BingdingKey和RoutingKey完全匹配的队列中
		topic: 
			* routingKey 为"."号分割的字符串(分割后的字符称为一个单词)。
			* BindingKey和RoutingKey一样是"."号分割的字符串
			* BingingKey存在"*"和"#",用于模糊匹配，其中"*"匹配一个单词,"#"号匹配多个单词(可以是0个或多个)
		headers:
			* 不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中headers属性进行匹配
			* 在绑定队列和交换器时制定一组键值对，对比其中的键值是否完全匹配队列和交换器绑定时指定的键值对
			* 路由性能差，不实用
			
			
2. Rabbitmq运转流程
	生产者:
		(1)连接到RabbitMQ Broker,建立一个连接(Connection)，开启一个信道(Channel)
		(2)生产者声明一个交换器，并设置相关属性(比如交换器类型、是否持久化)
		(3)生产者声明一个队列的相关属性，比如是否排他,是否持久化，是否自动删除等
		(4)生产者通过路由键将交换器和队列绑定起来
		(5)生产者发送消息只MQ,其中包含路由键、交换器等信息
		(6)相应的交换器根据接收到的路由键找匹配队列
		(7)如果匹配,将生产者发送的消息存入队列
		(8)不匹配，根据生产者配置是选择丢弃还是返回给生产者。
		(9)关闭 信道
		(10)关闭连接
	消费者：
		(1)连接到RabbitMQ Broker,建立一个连接(Connection)，开启一个信道(Channel)
		(2)消费者向Broker请求消费相应的队列中的消息，可能会设置相应的回调函数
		(3)等待Broker回应并投递相应队列中的消息，消费者接收消息
		(4)消费者确认(ack)接收到的消息
		(5)RabbitMq从队列中删除已经被确认的消息
		(6)关闭信道
		(7)关闭连接