按回收策略:
    1.引用计数：
        此对象有一个引用，则增加计数,删除一个引用则减少一个计数。垃圾回收时只删除计数为0的对象。但是无法处理循环引用的对象
        
    2.标记清除算法：
        第一阶段从引用根节点开始标记所有被引用的对象
        第二阶段遍历整个堆，把未标记的对象清除掉。
        此算法需要暂停整个应用，同时会产生一些内存碎片(对象在内存中的位置没有改变)
        
    3.复制算法：
        把内存空间分为两个相等区域，每次只使用其中一个。回收时将正在使用的对象复制到另外一个区域(不会产生内存碎片)
		其核心思想就是将内存空间分为两块，每次使用其中一块，在垃圾回收时，将其中使用的内存中的存留对象复制到未被使用的内存块中。
		之后清除之前正在使用的所有对象，返回交换两个内存角色，完成垃圾收集
    4.标记-整理 


    
按系统线程:
    串行收集: 使用单线程完成所有垃圾回收工作。
    并行收集:使用多线程处理垃圾回收，
    并发收集:垃圾收集时不需要暂停整个应用
    
    
分代垃圾回收:（不同代的回收频率不一样）
   不同对象的生命周期是不一样的，因此，不同生命周期的对象可以采用不同的收集方式，以便提高回收效率。    
    
   主要分为三个代:
        年轻代:所有新生成的对象首先放在年轻代。
            年轻代分为三个区：
                Eden区: 大部分对象存在的区域，
                两个Survivor区：
                    当Eden区满时,还存活的对象被复制到Survivor区1(两个中的一个)
                    当Survivor区1满时，此区还存活的对象被复制到Survivor区2.
                    当Survivor区2满时，从Survivor区1复制过来且还存活的对象将被复制到年老代。
                    Survivor区总有一个是空的。
        年老代：存放的都是生命周期较长的对象。
        持久代:主要存放Java类的类信息，和垃圾回收要收集的对象关系不大
        
什么情况触发垃圾回收:分为两种GC,Scavenge GC与Full GC
    Scavenge GC:当新对象生成，并且在Eden申请空间失败时触发。
        * 对Eden区域进行GC，清理非存活对象，并且把尚且存活的对象移动带Survivor区。然后整理Survivor两个区
        * Eden区不会分配很大，GC频繁，因此这里需要速度快、效率高的算法。
    Full GC:
        对真个堆进行整理，包括年轻代、年老代和持久代。回收速度慢
      有以下原因导致FullGC：
        * 年老代被写满
        * 持久代被写满
        * 显示调用System.gc()
        
        
 

资料来源:
    http://www.importnew.com/19255.html
        
          
        
    