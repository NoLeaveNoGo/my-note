1. 通过可达性分析算法中不可达的对象，也不是"非死不可"。这时候暂时它们处于"缓刑"阶段
2. 真正宣告对象的死亡，需要经历俩次标记过程。
	* 通过可达性分析发现没有与GC Roots相连接的引用链
	* 筛选后，判断是否有必要执行finalize()方法。如果对象没有覆盖finalize方法或者已经执行过，那么就"没有必要执行"
	* 执行finalize时没有把自己(this)赋值给某个类变量或者对象的成员变量，那么它就将被真正的"回收"

可达性分析过程:
	(1)枚举根节点
		从GC Roots节点找引用链这个操作为例，可作为GC Roots的节点主要在
			* 全局性的引用(例如常量类或类静态数据)与执行上下文(例如栈帧中的本地变量表)
			* 如果逐个检查这里面的引用，必然会消耗很多时间
			* 同时执行时间的敏感还体现在 GC停顿上

			