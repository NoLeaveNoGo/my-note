1.hotspot JVM: 是现在生产环境使用的典型JVM。



java虚拟机的基本结构
	1.类加载系统：
		负责从文件系统或者网络中加载Class信息，加载的信息存放在一块称之为方法去的内存空间
	
	2.方法区:
		存放类信息、常量信息、常量池信息(包括字符串字面量和数字常量等)
	
	3.java堆：
		在java虚拟机启动时简历java堆，它是java程序最主要的内存工作区域，几乎所有的对象实例都存放到java堆中
		堆空间是所有线程共享的
	
	4.直接内存
		java的NIO库允许java程序使用直接内存，速度会优于java堆
	
	5.每个虚拟机线程都有一个私有的栈，一个线程的java栈在线程创建时被创建。
		java栈中保存着局部变量、方法参数、同时java的方法调用、返回值等

	6.本地方法栈
	
	7.垃圾收集系统
	8.PC寄存器。线程私有的空间。寄存器中存放如当前环境指针、程序计数器、操作栈指针、计算的变量指针等
	9、执行引擎：负责执行虚拟机的字节码。 -->先编译成机器码再执行

堆、栈、方法区的联系
	堆解决数据存储的问题
	栈解决程序的运行问题，即程序如何运行，如何处理数据
	方法区则是辅助堆栈的快永久区(Perm),解决堆栈信息的产生。
	
	
java堆：
	* 最常见的是将java堆分为新生代、老年代两块区域。其中新生代存放新生的对象，老年代存放老年对象(通过gc的次数)
	* 新生代分为eden区、s0区、s1区(也称为from和to区) 复制算法
	* 对象首先分配在eden区，在一次新生代回收后，如果对象还存活，则进入s0或者s1，之后再经历一次新生代回收，存活年龄+1
	* 对象达到一定年龄后，进入老年代

方法区：可以理解为Perm区（永久区）	


2.java中的 内存你泄露:
    (1)如果不再使用的对象存在有效(但不再使用)的引用,任然会发生内存泄露
        * 例如，如果某个方法运行时间很长(或者一直运行下去)，那么这个方法中的局部变量就会一直保存对象的引用
        * hashMap中仍然存在两个对象之间的关联，因此在回收哈希表之前，这个两个对象会一直存在
        
3.标记清除算法：
        整个过程分三步:
            * 迭代分配表，把每个对象都标记为"已死亡"
            * 从指向堆的局部变量开始，顺着遇到的每个对象的全部引用向下,每遇到一个之前
              没有见到过的对象或数组，就把它标记为"存活",像这样一直向下，直到找出能从局部变量到达的所有引用为止。
            * 再次迭代分配表,回收所有没标记为"存活"的对象在堆中占用的内存,然后把这些内存放回可用内存列表中，最后把这些对象从分配表中删除。  